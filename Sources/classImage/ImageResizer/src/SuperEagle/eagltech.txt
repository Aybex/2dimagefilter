
eagle.h
-------

Version: 0.41a

Date : 10-August-1999


Features
--------

Graphics are enhanced through a interpolation and extrapolation.

Works line based per 2 consecutive lines.

Only supports 8bit color now, this will be enhanced to 16bit soon.  For eagle one byte represents one pixel.

Supports both non-MMX and MMX.  MMX is slightly faster than non-MMX.  Eagle automatically detects CPUs which supports MMX.

No color interpolation is done.



Supported Compilers
------------------

eagle.h is for use with DJGPP.  It uses x86 assembly through a coff object eagle.o
which should be used during linking.  eagle.o is generated through coff with NASM.

I haven't used eagle with MS Visual C, but it should work as well.  Let me know if you have.


Background
----------

Eagle needs a doubled resolution.  If the emulator normally outputs graphics
in for instance 320*240, then the Eagle resolution should be 640*480.
The colordepth remains the same (i.e. currently 8bit or 16bit).

In the rest of the explanation, the 320*240 example is used.

Eagle assumes the video, generated by the emulator looks like bitmap :

line1:   x1 x2 x3 x4 . . . . . .              . . . . . x320
line2:   x1 x2 x3 x4 . . . . . .              . . . . . x320
line3:   x1 x2 x3 x4 . . . . . .              . . . . . x320

...

line240: x1 x2 x3 x4 . . . . . .              . . . . . x320

	* Line240 is the last line.

	* Line2 starts exactly 320 bytes after Line1, i.e. there is no gap in 
	  memory between lines.

	* The bitmap generated by the emulator has in this example a size of 
	  320*240 = 76800 bytes.  This bitmap is called the source_bitmap.


Line Based
----------

All eagle rountines work lines based and should be called for every line in the
source_bitmap.

Eagle needs 2 consecutive lines, to determine its interpolation/extrapolation.

Per line for the source_bitmap, Eagle_Lines needs to be called.
Only for the last line in the bitmap, calling Eagle is not required, and could give garbage, as there is no next line for Eagle to derivate information of.
Thus eagle_Lines should be called 319 times for a buffer which has 320 lines.
Eagle will generate each time it is called 2 new lines with each a length of 320*2 = 640 bytes.  So for a 320*240 source_bitmap, (240-1)*2 = 478 lines  of length 640 are generated.


eagle
-----

eagle(	 int *Source_Line1
	,int *Source_Line2
	,int Width
	,int Destination_Segment    ( x86 ASM: DS register)
	,int Address_Screen_Line1
	,int Address_Screen_Line2 )

is the main procedure.  Where :

	Source_Line1 and Source_Line2 are pointers to the source_bitmap generated by 
	the emulator.

	Width is the width of the Source_Line in pixels (or for 8bit color, bytes).

	Destination_Segment is the segment used to address the videomemory (screen).

	Address_Screen_Line1 and Address_Screen_Line2 are both addresses to the video
	(screen).

This procedure takes input from the source_bitmap and copies it immediately to the
screen.


eagle_lines
-----------

eagle_lines(	 int *Source_Line1
		,int *Source_Line2
		,int Width
		,int *Buffer_Line1
		,int *Buffer_Line2 )

	Source_Line1 and Source_Line2 are pointers to the source_bitmap generated by 
	the emulator.

	Width is the width of the Source_Line in pixels (or for 8bit color, bytes).

	Buffer_Line1 and Buffer_Lines2 are both pointers to a temporary buffer where
	the eagled graphics are stored.


copy_eagle_buffer
-----------------

copy_eagle_buffer(	 int *Buffer_Line1
			,int *Buffer_Line2
			,int Width
			,int Destination_Segment
			,int Address_Screen_Line1
			,int Address_Screen_Line2 )

	Buffer_Line1 and Buffer_Lines2 are both pointers to a temporary buffer where
	the eagled graphics are stored.

	Width is the width of the Source_Line in pixels (or for 8bit color, bytes)
!	divided by 2!
	
	Address_Screen_Line1 and Address_Screen_Line2 are both addresses to the video
	(screen).



Preferable when using eagle these routines are used as they are highly optimized, especially the MMX version.  I haven't seen a faster implementation so far.
	